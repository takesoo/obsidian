---
tags:
  - book
  - 関数型プログラミング
---
why
	Next.js、フロントエンド開発での作法について理解を深めるため。引数で関数を渡したり、関数を返す関数があったり、パターンマッチングなど、オブジェクト指向にはない作法があるので、そのあたりについて疑問をなくしたい。

Q. 関数型プログラミングとは何か
A. 
	- 関数型プログラミングとは、①シグネチャが嘘をつかず、②本体が極力宣言的である関数（＝純粋関数）を使ったプログラミング。
	- イミュータブルな値を操作する純粋関数を使うプログラミング。
	- シグネチャが嘘をつかないとは、副作用がなく、例外が発生せず、シグネチャの通りに動作すること
	- 宣言的とは、処理をどのように行うかではなく、何を行う必要があるかに焦点を当てること

Q. なぜ関数型プログラミングをするのか
A. 純粋関数はイミュータブルで予期せぬ副作用がないため、扱いやすいかつバグの混入を防ぎやすい。

Q. なぜそのような考え方が生まれたのか

Q. 純粋関数とは
A. 
	純粋関数とは以下の特徴を持った関数のこと
		- 戻り値は常に1つだけ
		- 引数のみに基づいて戻り値を計算する
		- 既存の値を変更しない
	純粋関数は状態を持たない（ステートレス）である。状態が計算に必要な場合は引数で渡す。データそのものを変更せず（副作用をせず）データのコピーを計算して返す。計算をするのだから当然戻り値があり、戻り値のない関数は純粋関数になり得ない。
	純粋関数は引数に基づいて計算して値を返すので、テストが1行で記述でき、[[テスト容易性]]が高い
```java
// 命令型
class ShoppingCart {
	private List<String> items = new ArrayList<>();
	private boolean bookAdded = false;

	public void addItem(String: item) {
		items.add(item);
		if(item.equals("Book")) {
			bookAdded = true;
		}
	}

	public void removeItem(String: item) {
		items.remove(item);
		if(item.equals("Book")) {
			bookAdded = false;
		}
	}

	public int getDiscountPercentage() {
		if(bookAdded) {
			return 5;
		} else {
			return 0;
		}
	}

	public List<String> getItems() {
		return items;
	}
}

ShoppingCart cart = new ShoppingCart();
cart.addItem("Apple");
cart.addItem("Book"); // {items: ["Apple", "Book"], bookAdded: true}
cart.getItems().remove("Book"); // {items: ["Apple"], bookAdded: true} bookAddedがtrueのままになり、データ不整合

ShoppingCart cart2 = new ShoppingCart();
cart2.addItem("Apple");
cart2.addItem("Book"); // {items: ["Apple", "Book"], bookAdded: true}
cart2.addItem("Book"); // {items: ["Apple", "Book", "Book"], bookAdded: true}
cart2.removeItem("Book"); // {items: ["Apple", "Book"], bookAdded: false} bookAddedがfalseになり、データ不整合

// 関数型
class ShoppingCart {
	public static int getDiscountPercentage(List<String>: items) {
		if(items.contains("Book")) {
			return 5;
		} else {
			return 0;
		}
	}
}

List<String> items = new ArrayList();
items.add("Apple");
ShoppingCart.getDiscountPercentage(items); // => 0
items.add("Book"); // ["Apple", "Book"]
ShoppingCart.getDiscountPercentage(items); // => 5
items.remove("Book"); // ["Apple"]
ShoppingCart.getDiscountPercentage(items); // => 0
items.add("Book"); // ["Apple", "Book"]
ShoppingCart.getDiscountPercentage(items); // => 5
items.add("Book"); // ["Apple", "Book", "Book"]
ShoppingCart.getDiscountPercentage(items); // => 5
items.remove("Book"); // ["Apple", "Book"]
ShoppingCart.getDiscountPercentage(items); // => 5
```

Q. イミュータブルとは
A. 
	状態が不変であること。具体的には、引数自体、グローバル変数、ファイル、DBの値を直接変更をしないこと。コピーインスタンスを作成して操作する。関数型プログラミングはイミュータブルであることを基本としている。
	共有ミュータブル状態とは、コードベース内のさまざまなエンティティ間で共有され、それらによって変更される可能性のある変数のこと。共有ミュータブル状態があると状態の変更が思わぬところに影響してしまい、参照透明性が下がり、エンジニアの認知負荷が上がり、コードの品質が下がる。
	コピーインスタンスを作成するのでメモリ効率は悪いのだが、コードベースの読みやすさと監理のしやすさのメリットが先のデメリットを大きく上回る。
```java
/**
 * 旅程(plan)のbeforeCityの前にnewCityを追加する
 * planは共有ミュータブル状態
 * planを直接変更しているため、これは純粋関数ではない
 */
static List<String> replan(List<String> plan, String newCity, String beforeCity) {
	int newCityIndex = plan.indexOf(beforeCity);
	plan.add(newCityIndex, newCity);
	return plan
}

List<String> plan = new ArrayList("Paris", "Berlin", "Krakow");
List<String> newPlan = replan(plan, "Vienna", "Kradow"); //=> ["Paris", "Berlin", "Vienna", "Krakow"]
plan //=> ["Paris", "Berlin", "Vienna", "Krakow"]

/**
 * OPPアプローチではカプセル化でイミュータブルにする
 * planは外部に公開されず、メソッドを介してのみ変更ができる
 */
class Itinerary {
	private List<String> plan = new ArrayList<>();

	public void replan(List<String> plan, String newCity, String beforeCity) {
		int newCityIndex = plan.indexOf(beforeCity);
		plan.add(newCityIndex, newCity); // データを直接変更する
	}

	public void add(String city) {
		plan.add(city);
	}

	public List<String> getPlan() {
		return Collections.unmodifiableList(plan); // 内部データを漏らさないように注意を払い、コピーまたはビューを返してデータを保護する。クラスが大きになるにつれてミスしやすくなる
	}
}

/**
 * FPアプローチ
 * コピーインスタンスを作成してデータ加工する
 * 渡された引数を直接変更しない
 */
static List<String> replan(List<String> plan, String newCity, String beforeCity) {
	int newCityIndex = plan.indexOf(beforeCity);
	List<String> replanned = new ArrayList<>(plan); // コピーを作成する
	replanned.add(newCityIndex, newCity); // コピーに対してデータ加工する
	return replanned;
}
```

Q. 値としての関数とは

Q. 関数を渡す？

Q. 関数を返す？

Q. カリー化とは？

Q. 高階関数？
（5章以降は関数型プログラミングの実践。↑を理解した後で追加のQを考える）