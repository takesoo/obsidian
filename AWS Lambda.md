---
tags:
  - AWS/Lambda
aliases:
  - Lambda
---
## what
- サーバレスで関数を実行するサービス
- ランタイムを抽象化したサービス
- ソースコードのデプロイはZIP形式かDocker Image形式
	- Docker Imageでアップロードする場合
		- docker build
		- docker push ECR_REPO_URI:latest
		- lambdaで↑のイメージを使用するように定義
- 内部的にはFirecrackerという技術をベースに稼働している。コンテナのようなもの。
- Lambda関数: AWS Lambdaで実行するアプリケーションそのもの
	- コードは依存関係も含めてビルド、パッケージングした上でS3に暗号化されて保存される
	- メモリ
		- 128MB~3008MBの間で64MBごと
		- 容量に応じてCPU能力なども比例する
	- タイムアウト
		- 最大900sec(15min)
	- 実行ロール: AWSリソースへのアクセスを許可する[[IAMロール]]
- ハンドラー関数: Lambdaが実行する際のエントリーポイントとなる関数
	- json形式のイベントデータにアクセスできる
```python
def lambda_handler(event, context):
    # event: イベントデータ
    # context: 実行環境の情報
    return {
        'statusCode': 200,
        'body': 'Hello World'
    }
```
- コンテキスト：ランタイムに関する情報
	- ハンドラー関数の二つ目の引数
- ロギング
	- CloudWatch Logsに書き込まれる
- 例外
	- 言語によって正常終了する方法が異なる
	- 例外処理方法も異なる
- イベントソース: Lambdaの実行を起動するトリガーとなるデータや出来事
	- API Gateway, S3, DynamoDB, CloudWatch Events, SQS, SNS
	- ポーリングベース: Lambdaがポーリングして処理するデータがある場合に実行する
		- ストリームベース
			- [[DynamoDB]], [[AWS Kinesis]], etc
		- ストリーム以外
			- [[AWS SQS]]
	- ポーリング以外: 呼び出し元のサービス側からLambdaを呼び出す
		- イベントソースマッピング：呼び出し元のサービス側で、呼び出すLambdaファンクションの設定情報を保持する
- 呼び出しタイプ(InvocationType): 非同期呼び出しor同期呼び出し
- リトライ処理
	- ポーリングベースではない
		- 同期呼び出しの場合はレスポンスヘッダにFunctionErrorが含まれ、ステータスコードが返る
		- 非同期呼び出しの場合は2回リトライされ、その後破棄されるかDead Letter Queueになる
	- ポーリングベースかつストリームベース
		- データの有効期限が切れるまでリトライを行う
		- 失敗したレコードの有効期限が切れるか、処理が成功するまで、そのシャードからの読み込みはブロックされ、新しいレコードの読み込みは行われない
	- ポーリングベースだがストリームベースではない
		- バッチのメッセージがキューに返り、Visibility Timeoutがすぎるまでリトライされる
		- 新しいメッセージの処理はブロックされない
- VPCアクセス：VPC内のリソースへインターネットを経由せずにアクセスできる
	- VPCサブネットおよびセキュリティグループを指定する
- 同時実行数
	- アカウントに対して1000
	- 実績に応じて制限緩和申請が可能
	- スロットリングエラー(error code 429)
	- トラフィックの増加に応じて自動スケーリング
- Layer: 複数の関数で共有できるライブラリやコードのパッケージ
- Lambda実行環境([Lambda 実行環境 - AWS Lambda](https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-runtime-environment.html))
![[Pasted image 20250910093611.png]]
	1. Initフェーズ
		- Lambda関数の初期化
			- 拡張機能の起動、ランタイムのブートストラップ、静的コード（ハンドラー関数外のコード）の実行
	2. Restoreフェーズ(SnapStartのみ)
	3. Invokeフェーズ
		- ハンドラー関数が呼び出され、指定のタイムアウト内で関数本体と拡張機能が実行される
	4. Shutdownフェーズ
		- 実行環境終了時に拡張機能へ通知され、クリーンアップ処理が行われる
	- コールドスタート: Lambda関数を1から起動させること
	- ウォームスタート: 起動済みのLambdaコンテナに対してInvokeフェーズだけ実行すること。
- Lambda Extensions: Lambda関数と並行して実行される軽量なプロセスで、Lambda関数のライフサイクル全体を通じて動作し、監視、セキュリティ、ガバナンス、その他の機能を提供する
- Lambdaエイリアス：特定のバージョンに対するエイリアス。devやprodなど
- 修飾ARN：バージョン番号やエイリアス名が末尾に付与されたLambda関数のARN。特定のバージョンを明確に指定して関数を呼び出すために使用される。
## how
- Lambda関数はステートレスにする必要がある
	- コンピューティングインスタンスの指定はできない。ローカルファイルシステムへのアクセスや子プロセスは使用できない
- ハンドラ、コンテキスト、ロギング、例外処理、トレースを実装する
	- Lambda関数の設定
- アカウント単位で許可された同時実行数をファンクション単位で任意に割り当てることが可能。
- 環境変数が使用可能。[[AWS KMS]]や独自のキーによる暗号化も可能。
- バージョニング
	- 一位のARNが割り当てられる
	- バージョンには構成も含めて変更されなくなる
	- エイリアス
		- 特定バージョンに対するポインタのようなもの
		- routing-configを使用することで新旧のバージョン間でのリクエストトラフィックが転送される割合を決められる。カナリアデプロイが可能
		- ARNの末尾に:で繋げる
- イベントやダウンストリームも合わせて[[AWS X-Ray]]で監視するのが良い
## ベストプラクティス・アンチパターン
- いかに関数を効率よく実行するか。コールドスタートに関わる部分を早くする。コード実行自体を早くする。
- コールドスタートを速くする
	- コンピューティングリソースを増やす
		- コストを気にしがちだが実際には処理時間が減って結果的にコストはそれほど変わらず性能が上がることもある
		- 少しずつ調整し（上げていき）、変更しても性能が変わらない値が最適値
	- ランタイムを変える
	- パッケージサイズを小さくする（あまり効果は大きくない）
	- VPCは必要でない限り使用しない
		- VPC内のリソースにどうしてもアクセスする必要がある時だけ
- 関数コード
	- Fatでものりシックな関数にならないようにする
		- 単一責務
		- 関数内でのオーケストレーションは禁物
	- ハンドラとコアロジック（ビジネスロジック）は分離させる
		- コアロジックの単体テストがしやすくなる
	- コンテナの再利用を有効活用する
		- AWS SDKのクライアントやDBクライアントの初期化をハンドラの外で行うことでインスタンスを使いまわせる
	- 必要なもののみ読み込む
		- 読み込んで絞り込むのではなく、そもそも絞り込んでから読み込む
	- コード内でオーケストレーションしない
		- [[Step Functions]]を利用する
	- レジリエンシの向上
		- エラーハンドリング
		- Lambdaのリトライポリシーを理解する
		- Dead Letter Queueを活用する
	- 複雑な依存関係を避ける
	- 組み込まれたSDKは使用しない
		- Lambdaサービス側で定期的に更新されてしまうため
		- 関数で使用される依存関係は完全にユーザーで管理してパッケージングすることを推奨する
	- 非同期実行を活用する
		- 同期の場合同時実行数の制限に引っかかって詰まりがち
	- 冪等性を確保する
		- まれに2回起動されることがある
		- イベントIDをDynamoDBに保管して処理実行前にチェックするなど
	- 並列処理で同時実行できるアーキテクチャにする
	- ハードコーディングしない
		- 環境変数を利用する
		- 機密情報は[[Parameter Store]]や[[AWS Secrets Manager]]の利用も検討する
- ストリーム型のイベントソースを利用する上でのプラクティス
	- バッチサイズを大きくするとLambdaの同時実行数を節約できる
		- ただし１ファンクションで処理できるデータは最大6MBまで
	- Lambda関数は常に成功を返すようにして、関数コード内でログ出力やDLQへ失敗したレコードの情報を送る
		- 処理が失敗するとデータが期限切れになるまでシャード全体がブロックされてしまうため
		- ここで利用するDLQはLambdaの設定ではなく、自前で用意したもの
	- 複数のコンシューマーを用意するのは避ける
		- スループットの問題が起こりがちになるため
		- スケールさせるには[[Fan-out Fan-inパターン|Fan-out]]パターンの検討を
	- Kinesis/DynamoDBのようにリトライや順序が重要でない場合は[[AWS SNS]]の利用も検討する
## セキュリティ