---
Status: 読みかけ
Auther: 
Purpuse: メンテナンス性の高いコードを書けるようになるため
Summary: 
Start: 2023-11-01
End: 
tags:
  - book
  - コーディング
  - 良いコード悪いコードで学ぶ設計入門
---
## [[第1章 悪しき構造の弊害を知覚する]]
- 意味不明な命名は可読性を下げる
- 条件分岐の深いネストも可読性を下げる
- データクラスは低凝集や生焼けオブジェクトなどになり保守性を下げる
## [[第2章 設計の初歩]]
- 意味が伝わる命名は可読性を上げる
- 変数への再代入をしない
- 単一責務でメソッドを分割する
- 関係性の高いデータとロジックをクラスにまとめて凝集度を上げる
## [[第3章 クラス設計]]
- クラス設計とは、==インスタンス変数を不正状態に陥らせないための仕組みづくり==
- コンストラクタにガード節を入れて不正値の混入を防ぐ
- インスタンス変数は不変にし、変更の際には変更値を設定したインスタンスを新たに生成して返す
- [[完全コンストラクタ]]
- [[値オブジェクト]]
## [[第4章 不変の活用]]
- 変数は不変にして、値の再代入は基本的に禁止する。変数の意味が変化してしまいバグを招く要因になるため。
- インスタンス変数も不変にする。インスタンスの使い回しを許容する作りなので、別のスレッドなどで施した状態変化が別のスレッドに影響したりする（副作用）。
- 関数の主作用と副作用を意識して設計する
- インスタンス変数を不変にすることで、メソッドは状態変更後のインスタンスを生成して返すロジックになる
## [[第5章 低凝集]]
- staticメソッドは、凝集度に影響しない場合を除いて、基本的に使用しない
- 初期化ロジックが分散しないようにファクトリメソッドを用意する
- CommonやUtilといったクラスには横断的関心事の処理をまとめて、それ以外は値オブジェクトへの実装を検討する
- 出力引数のあるメソッドはほかのクラスにも実装される可能性があるので、そのメソッドは出力引数のクラスに実装して凝集度を上げる
- 引数が多いとメソッド内でバリデーションをしている可能性があり、そのバリデーションは他のクラスで実装されていたりする。引数で渡すのではなく、インスタンス変数として設計変更を検討する。
- メソッドチェインはメソッドの呼び出し元がいたずらに増えてしまい、保守を辛くする。呼び出し元が呼び出し先の内部詳細を把握するのではなく、呼び出し先で判断させる。尋ねるな、命じろ。
## [[第6章 条件分岐]]
- ネストの深い条件分岐は早期returnで解消する
- 処理を分岐するswitch文は至る所に重複するので、ストラテジパターンで解消する
- 複雑な条件分岐はポリシーパターンで条件を集約する
- 一見ストラテジパターンに見えても、型チェックでの条件分岐しているとリスコフの置換原則に違反しているので、ちゃんと抽象クラスと具象クラスにメソッドを実装する
- フラグ引数もストラテジパターンを使用できるチャンス
## [[第7章 コレクション]]
- コレクションに対する処理は、まず言語の標準ライブラリを利用できるか検討する
- ループ処理中は早期continue、早期breakでネストを解消する
- ファーストクラスコレクションを利用してコレクションに対するロジックをカプセル化する
## [[第8章 密結合]]
- 誤った継承の使用は密結合を生んでしまう。継承よりも委譲（[[コンポジション構造]]）をまず考えてみること。
- インスタンス変数やメソッドの依存関係を[[影響スケッチ]]などで把握して、依存関係が独立している部分はクラスを分割する
- メソッドは基本的にpackage privateとし、パッケージ外に公開が必要なメソッドのみpublicにする
- privateメソッドが多すぎるクラスは異なる責務が実装されている可能性が高いので単一責務になるようにクラスを分ける
- 高凝集を誤解して、関係してそうなロジックを一つのクラスにまとめてしまっている場合も単一責務の視点でクラスを分ける
- [[スマートUI]]、[[巨大データクラス]]、[[トランザクションスクリプトパターン]]、[[神クラス]]なども、[[オブジェクト指向|オブジェクト指向設計]]と[[単一責務の原則]]に基づいて丁寧に設計すれば、大抵の場合は100行程度のクラスになる
## [[第9章 設計の健全性をそこなう様々な悪魔たち]]
- デッドコードを残さない
- 仕様を先回りして設計しない。必要な機能だけを実装する。
- マジックナンバーは定数として定義する
- グローバル変数を定義しない
- nullを返さない、渡さない。0などの初期値をセットする
- 例外を握りつぶさない
- メタプログラミングはデメリットがあるので用途を限定すること
- 技術駆動パッケージングではなく、ビジネス概念でパッケージングすること
- サンプルコードのコピペはしてはいけない
- 銀の弾丸はない
## [[第10章 名前設計]]
- [[目的駆動名前設計]]をする
- 意図がわからない名前をつけない
- xxxInfoやxxxDataはデータクラスになりやすく、xxxManagerは神クラスになりやすいので避ける
- 「動詞＋目的語」や不自然に長い名前のメソッドは定義しているクラスが間違っているかもしれない
- 名前の省略は基本的にしないこと
## [[第11章 コメント]]
- コードと同様にコメントも仕様変更に合わせて更新されなければならない
- 意図や仕様変更時の注意点をコメントで読み手に伝える
- [[ドキュメントコメント]]も有効
## [[第12章 メソッド]]
## [[第13章 モデリング]]
- システムとは、多数の構成要素が連携して、全体として一つの目的を達成するもの。言い換えれば、目的達成のための手段。
- モデリングとは、システム構造を単純化して図示する（モデル化）ことで全体像を設計すること
- 目的ごとに定義を絞ることでモデルを小さく分割できる。一つのモデルは一つの目的を達成するために存在する（単一責任）。従って現実世界の物理的な存在と情報システム上のモデルは1:多の関係になることもある。
- ただし一つのモデルが複数のクラスによって構成されることもある
## [[第14章 リファクタリング]]
- ネストの解消、ロジックをまとめ、条件やベタ書きのロジックをメソッドにする
- ユニットテストでコードの振る舞いが変わっていないことを担保する
- リファクタリングの見通しを立てる。値オブジェクト、デザインパターン、etc
- 仕様があやふやなら仕様化テストや試行リファクタリングなどで理解を深める
- 機能追加とリファクタリングは同時にせず、コミットを分ける。
- リファクタリングはスモールステップでコミットを分ける
- 無駄な仕様はそれ自体を削除することも検討する
## [[第15章 設計の意義と設計への向き合い方]]
- 正しく設計すると開発生産性が高まる
- 正しく設計するとソフトウェアの成長性が高まる
- 正しく設計するとエンジニアの成長性も高まる
- 正しい設計ができているかどうかは、コードメトリクスで判断できる
- リファクタリング対象は仕様変更頻度、コアドメインに集中すべきであり、その選定にはビジネス知識が必要になる
## [[第16章 設計を妨げる開発プロセスとの戦い]]
- 開発プロセスが原因で品質が落ちることがある
- 逆コンウェイの法則を利用したチーム編成、チームの心理的安全性を高めることで、コミュニケーションを活発にする
- チームに設計の概念とプロセスを定着させる。
- 設計と実装のフィードバックサイクルを回す。
- 粗悪なコードの放置を許さず、自分が変更を加える部分には綺麗な状態にしてコミットする（[[割れ窓理論]]と[[ボーイスカウトの規則]]）
- ソフトウェアの目的やユビキタス言語の理解に務める
- コードレビューする
- 設計することの費用対効果をリーダー、マネージャーに理解してもらう
## [[第17章 設計技術の理解の深め方]]
- さらにステップアップするための技術書を読む
- インプット以上にアウトプットを多くこなす。日々の業務を利用する。
- 動くコードを書いたら、変更容易性の観点から見直し、設計し直す

---
## [[ロジックツリー（良いコード悪いコードで学ぶ設計入門）]]