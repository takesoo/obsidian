---
tags:
  - アルゴリズム
---
データを[[木構造]]で保持させて、それをヒープ木になるように並べ替える。完成したらルートの値を配列に戻し、同様の処理を繰り返して整列させる。
1. 配列から木構造を作る
	\[4, 3, 9, 8, 2, 7, 5, 1]

```mermaid
graph TD
	4((4))
	3((3))
	9((9))
	8((8))
	2((2))
	7((7))
	5((5))
	1((1))

	4---3
	4---9
		3---8
		3---2
		9---7
		9---5
			8---1
```
2. 親<子になるようにリーフ側から並べ替える
```mermaid
graph TD
	4((4))
	3((3))
	9((9))
	8((8))
	2((2))
	7((7))
	5((5))
	1((1))

	4---3
	4---9
		3---1
		3---2
		9---7
		9---5
			1---8
```
※mermaidのレンダリングの影響で左端が2になってるが本当は3-8が左端
```mermaid
graph TD
	4((4))
	3((3))
	9((9))
	8((8))
	2((2))
	7((7))
	5((5))
	1((1))

	4---1
	4---5
		1---2
		1---3
		5---7
		5---9
			3---8
```
```mermaid
graph TD
	4((4))
	3((3))
	9((9))
	8((8))
	2((2))
	7((7))
	5((5))
	1((1))

	1---4
	1---5
		4---2
		4---3
		5---7
		5---9
			3---8
```
3. ルートの値を配列に取り出す
4. 左端または右端のリーフをルートにして2, 3を繰り返す
	※左端は8
```mermaid
graph TD
	4((4))
	3((3))
	9((9))
	8((8))
	2((2))
	7((7))
	5((5))

	8---4
	8---5
		4---2
		4---3
		5---7
		5---9
```



