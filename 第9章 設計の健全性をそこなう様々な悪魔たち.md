---
tags:
  - 良いコード悪いコードで学ぶ設計入門
---
- [[デッドコード]]
	- 条件分岐によって到達不能であり、実行されないコード
	- 読み手は到達可能を前提にしているので到達条件を考えさせてしまう
	- なぜ実行されないコードが残っているのか意図をさぐってしまう
	- 仕様変更によって到達可能になり、バグとして顕在化する
- [[YAGNI原則]]
	- You aren't going to need it.(必要ないでしょう)
	- 仕様になってない部分を先回りして作ってもほとんどの場合使用されないでデッドコードとなる
	- 今必要な機能だけを作り、構造をシンプルにして、可読性と保守性を高く保つべき
- [[マジックナンバー]]
	- ロジック内に直接書き込まれた数値
	- 実装者本人にしか意図が理解できない
	- 複数の箇所で実装されて重複コードになる
	- 定数として定義する
- 文字列型執着
	- 複数の値を区切り文字で区切って一つの変数に格納したもの
	- 可読性が低く、変更にも弱い
- [[グローバル変数]]
	- どこからでもアクセス可能な変数
	- 多くのロジックでグローバル変数を参照し、値を変更していると、どのタイミングで値が書き換わったのか把握が非常に困難になる
	- 排他制御が必要になり、パフォーマンスの低下やデッドロックの危険性が生まれる
	- 影響範囲を最小化するように設計すること
		- 無関係なロジックからはアクセスできないように設計する。呼び出し箇所が少なく、局所化されているほど、ロジックの理解が容易になる。
- null問題
	- nullが入り込む前提でロジックを組むと、至る所でnullチェックをしなければならない。nullチェックだらけでコードの見通しが悪くなるし、nullチェックが漏れるとバグになる。
	- nullを返さない、渡さない
		- nullではなく、0などの初期値をセットする
	- [[null安全]]
		- nullが原因のエラーを発生させないしくみ
		- null非許容型など、一部のプログラミング言語はnull安全の使用を持つものがある
- 例外の握り潰し
	- 