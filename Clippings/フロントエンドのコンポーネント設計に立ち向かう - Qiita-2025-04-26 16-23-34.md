---
finished reading: false
favorite: false
tags:
  - clippings
---
# フロントエンドのコンポーネント設計に立ち向かう - Qiita
  #ReadItLater 
 #ReadableArticle

## articleURL
https://qiita.com/seya/items/8814e905693f00cdade2

## siteName
Qiita

## date
2025-04-26

## articleContent
ReactやVueなどコンポーネントベースで作っていくViewのライブラリが普及したことで、コンポーネント指向での開発が一般化してきた昨今のフロントエンドですが、このコンポーネントの設計に悩まれる方も多いのではないでしょうか。

コンポーネントをどの粒度、どんな状態で分割するのが良いのか、などなど、特にチームで開発する時に認識が揃っていないとカオスになりがちな部分であると思うので、自分なりの設計をする際の指針を言語化しようというのが本記事の目的です。同じように悩まれている方にも何らか示唆を提供することができたら嬉しいです。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#%E6%83%B3%E5%AE%9A%E8%AA%AD%E8%80%85)想定読者

-   「コンポーネント設計？なにそれ？おいしいの？」という方
-   初めてコンポーネント設計でアプリ作ってみたけど、本当にこれでいいのか自信の無い方

## [](https://qiita.com/seya/items/8814e905693f00cdade2#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB-%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%A8%E3%81%AF)はじめに: "コンポーネント"とは

まず最初に"コンポーネント"という言葉についてですが、ここでは「GUIのパーツをモジュール化したもの」と定義します。

GUIは基本的にはPC・スマホなどのデバイス上の画面に存在し、その中にアプリケーションで達成したいゴールを満たすための機能を散りばめていくこととなります。アプリケーションは複数の画面で構成されることが多く、同じパーツが繰り返し使われることが頻発します。例えばヘッダーやフッターなんかはほぼ全部の画面に登場するでしょうし、ボタンやテキストフィールドなども同じスタイルを持ったものが複数の画面で繰り返し使われるでしょう。  
この様々な粒度のパーツを"コンポーネント"と呼ばれる単位に区切って再利用性を高めるのと同時に、デザインと技術の共同作業をしやすくするのがコンポーネント化の目的です。

そして、このコンポーネントを構成する要素は以下の4つがあります。

1.  情報構造
2.  スタイル
3.  状態
4.  インタラクション・機能

[![スクリーンショット 2018-04-01 13.14.51.png](Clippings/assets/フロントエンドのコンポーネント設計に立ち向かう%20-%20Qiita-2025-04-26%2016-23-34/スクリーンショット%202018-04-01%2013.14.51.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F150569%2F5e2d974b-aaaf-35de-8f57-893da03634ca.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=28d9ed1e4140b157908ada4b214c551d)

まず「情報構造」、小難しく表現しましたがこれはHTMLが責務を持つ部分です。そして「スタイル」はCSSが責務を持ちます。これらの観点は初めにコンポーネント設計をする際にイメージしやすい部分で、単純にAtomic Designなどの思想に則ってUIパーツを分解して行けば、ここだけならあんまり難しいことはないはずです。

ただ、最近のフロントエンドはそんなことは許してくれず、なぜなら、コンポーネント自身が状態やその変化のトリガーとなるインタラクションについて責務を持つからです。コンポーネントは外部とのデータやコールバックの受け渡しも行う必要があるため、実装効率上の観点での制約が生まれます。コンポーネント化する目的はあくまでエンジニアの生産性向上のため、概念としての綺麗さと実装のしやすさがコンフリクトすることは往々にして起こります。

これらのような複数の役割をカプセル化したものであることがコンポーネントの設計を難しくしている要因なのではないかと思っています。これ以降ではそれぞれの観点に対して「私はこんな感じで軸を置いている」というのをご紹介いたします。

## [](https://qiita.com/seya/items/8814e905693f00cdade2#%E6%83%85%E5%A0%B1%E6%A7%8B%E9%80%A0%E3%81%A8%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB)情報構造とスタイル

情報構造とスタイルは密接した概念であるためくくります。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#%E5%8E%9F%E5%89%87%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE-atomic-design)原則としての Atomic Design

まずは概念としてのUIパーツのレイヤー分けの仕方の認識を揃えることが基本となります。  
ここに関してはAtomic Designがデファクトスタンダードになっている感がありますので、まずはこれを抑えることをオススメします。

Atomic Designはざっくり説明すると以下の５要素にコンポーネントを分割していくデザイン手法です。

▼ よく見るAtomic Designの図  
[![1_j1P0pjQtl36QJavv8lHdyw.png](Clippings/assets/フロントエンドのコンポーネント設計に立ち向かう%20-%20Qiita-2025-04-26%2016-23-34/1_j1P0pjQtl36QJavv8lHdyw.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F150569%2F73ffc43a-a181-fad9-a16e-f9b894475f85.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=dedbf785e952bb329aad2a24a7c7baff)

-   Atom - UIの最小単位。それ以上機能的に分割できないもの。ボタンとかテキストとか。
-   Molecule - Atomを組み合わせて作られる要素。検索フォームとか。
-   Organisms - MoleculesやAtomを組み合わせて作られる要素。ヘッダーとかがイメージしやすい。Moleculeとの違いは単一の機能でなく複数の役割を持つこと
-   Template - Organismsを組み合わせたもの。いわゆるワイヤーフレーム
-   Pages - 実際の文言などのデータがTemplateに注ぎ込まれたもの。

詳しい解説は他にいい記事がたくさんあるので、リンクを貼っておきます。

-   [珍しいワークフロー：Atomic Designの原則とSketchでデザインからプログラミングまで](https://postd.cc/the-unicorn-workflow-design-to-code-with-atomic-design-principles-and-sketch/)
-   [Atomic Designの考え方と利点・欠点](http://blog.kubosho.com/entry/using-atomic-design)

### [](https://qiita.com/seya/items/8814e905693f00cdade2#%E5%8D%98%E4%B8%80%E8%B2%AC%E4%BB%BB%E3%81%AE%E5%8E%9F%E5%89%87)単一責任の原則

原則としてコンポーネントは一つのことに責任を持つべきです。

これはMolecule単位のコンポーネントをデザインする時に重要な考え方で、一つのコンポーネントが複数の機能・役割を持ってしまっているのはよくない設計の兆候です。  
なぜ良くないかと言うと再利用性が低くなるからです。

例えばこんな感じの「ユーザ名の変更」と「外部サービスの連携」の二つの役割を背負わせたものを一つのコンポーネントとして作ってしまったとします。  
[![スクリーンショット 2018-04-01 13.33.52.png](Clippings/assets/フロントエンドのコンポーネント設計に立ち向かう%20-%20Qiita-2025-04-26%2016-23-34/スクリーンショット%202018-04-01%2013.33.52.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F150569%2Fe7217e9c-8873-2e88-80bc-a250e9ea0083.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=84f6680c2a0fe9cc2cbd6b7218228ed6)

そして、これを使っているページとは別のページで「"ユーザ名"と"外部サービス連携"を逆の順序にしたい」だったり「"ユーザ名"と"外部サービス連携"の間に"アイコン変更ボタン"を設置したい」などの要求が発生するとします。そうなると、この哀れなコンポーネント内で面倒な条件分岐を作ることになり、また使う側の親コンポーネントもこのコンポーネントのスタイルについて詳しく知らなければならず密結合になってしまいます。これが最初から「ユーザ名の変更」と「外部サービスの連携」でそれぞれ別のコンポーネントになっていれば、単純に並べ替えたり、新しいコンポーネントを追加するだけで済みます。

若干極端な例にはなってしまいましたが、言わんとしていることは伝わったと願います。

ここまで読んで「じゃあOrganisms以上はどう捉えたらいいんだ、複数の役割を持っているじゃないか」と感じる方もいらっしゃる方もいるかもしれません。それに関して私は、Organisms以上の単位のコンポーネントは「機能としての役割」は持たず「レイアウトとしての役割」を持つ、と捉えています。

どういうことかと言うと、例えばQiitaのヘッダー、コミュニティ関連のドロップダウンがあったりお知らせがあったりマイページへのボタンがあったり機能がたくさんありますね。

[![スクリーンショット 2018-04-01 13.29.34.png](Clippings/assets/フロントエンドのコンポーネント設計に立ち向かう%20-%20Qiita-2025-04-26%2016-23-34/スクリーンショット%202018-04-01%2013.29.34.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F150569%2Ffe1ccba7-262d-4480-1c14-4fcdbf3912dd.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=19cbc7fd53fb0f0d530f4c29b68a3be7)

ただこれはヘッダーというコンポーネントそれ自体が機能を持っているのではなく、あくまで機能を実現しているのはヘッダー内に内包された個別のMolecule or Atomたちです。  
ヘッダーはあくまで「これらのMolecule or Atomたちをどうレイアウトするか」にだけ責任を持ちます。

要するにコンポーネントの責務の種類は単純な機能だけでなくレイアウトも含む、と考えると線引きがつけやすくなると思います。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%BA%E3%83%89%E3%81%AE%E5%8E%9F%E5%89%87)スタイルクローズドの原則

上記の話ですが、スタイルについても同じようなことが言えます。  
まずスタイルと呼ぶものの中にも私は以下の2種類があると思っています。

1.  見た目のスタイル
2.  レイアウトのスタイル

"見た目のスタイル" とは対象のコンポーネントの見た目を定義するものです。  
対して、"レイアウトのスタイル"　についてですが、これは単位がMolecule以上のコンポーネントに関して、そのコンポーネントが内部のコンポーネントたちをどうレイアウトするかを定義するスタイルのことです。

ここで唱えたいのが、この親子関係において

-   「子コンポーネントは親コンポーネントの"レイアウトのスタイル"を知ってはならない」
-   「親コンポーネントは子コンポーネントの"見た目のスタイル"を知ってはならない」

ということです。ちなみにどちらも理由は「再利用性が低くなるから」です。(というか設計のアンチパターンの理由は大体これ)

例えば、こんな感じのアイコンが複数並べたコンポーネントが存在するとします。

[![スクリーンショット 2018-03-25 12.34.50.png](Clippings/assets/フロントエンドのコンポーネント設計に立ち向かう%20-%20Qiita-2025-04-26%2016-23-34/スクリーンショット%202018-03-25%2012.34.50.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F150569%2F3904001b-eab8-66a3-e906-cb175248de7a.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=ad191cd5947bbcbe5b7408f9696200f3)

アイコンの間には`margin`が等間隔でありますね。  
この`margin`をアイコンコンポーネント内で定義していたとしましょう。

```
.icon {
  ...
  margin-right: 15px;  
}
```

さて、他のページでこのアイコンを使いたいとなったとします。そして今回はアイコンの右に対して`margin`が`100px`必要なレイアウトだとします。この時どこにどう`margin`のスタイルを記述して実現すると良いでしょう？

解決方法は色々ありますが、どんな選択肢であろうとこのアイコンコンポーネント内の`margin`を気にしなくてはならないと思います。そしてそんな解決策が積み重なっていくとどんどん汚いCSSが増えていくことは容易に想像できると思います。

このため子のコンポーネントは親にどんなレイアウトで使われるのかについてのスタイルは記述するべきではなく、また逆もまた然りで親も子の見た目のスタイルについて(あまり)立ち入ってはなりません。スタイルもそのコンポーネントの役割に応じて閉じたものにしましょう。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#%E5%8F%AF%E5%A4%89%E3%81%AB%E3%81%99%E3%82%8B%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%82%92%E8%A6%8B%E6%A5%B5%E3%82%81%E3%82%8B)可変にするスタイルを見極める

若干先ほど述べたことに反するのですが、時には親から子に対してある程度スタイルを指定できるようにした方が利用しやすいいいコンポーネントになります。

例えばなんですがアプリケーション内に以下の２種類のボタンがあるとします。

[![スクリーンショット 2018-04-01 9.11.43.png](Clippings/assets/フロントエンドのコンポーネント設計に立ち向かう%20-%20Qiita-2025-04-26%2016-23-34/スクリーンショット%202018-04-01%209.11.43.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F150569%2Fffd527f7-169c-55bc-ed23-5c6f90747037.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=3edd4fa048616d45f24cf5727a0d5b10)

違うのは幅だけです。それを理由に二つの独立したコンポーネントを作ってしまうのは少々面倒ですよね。なので親が使う際に幅を指定できるようにしてあげると良いでしょう。

これは分かりやすい例ですが、その他にも背景色だったりテキストの色だったり可変にしたいスタイルが色々出てくると思うので、都度判断して行きましょう。

基本的な考え方としては「原則スタイルはコンポーネントに閉じたものにする。可変にする必要・メリットが出てきた時に可変にする」というスタンスで良いと思います。「このスタイル可変にしとくと後々便利そう」というフィーリングで判断するのはオススメできません。大抵必要にならず、また後になってからでも可変にする修正コストは大して高くありません。YAGNIの精神で行きましょう。

## [](https://qiita.com/seya/items/8814e905693f00cdade2#%E7%8A%B6%E6%85%8B%E3%81%A8%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%A9%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3)状態とインタラクション

続きまして、状態とインタラクション。こちらも括ります。

初めに「状態」という言葉、割と定義がふわふわしがちだと思うので最初に述べておこうと思います。

ツッコミどころはあるとは思いますが、個人的には以下の定義で捉えています。  
「アプリケーションの動作時に変動しうる値」

広義の意味では上記の通りですが、その中でも何種類かの状態に分かれます。(他にも色々あると思います)

-   データ
-   UI
-   セッション
-   通信
-   Location(Routingとかの話)

「どのコンポーネントがどの状態を扱うのか」という問いは重要なテーマとなります。そして、この状態は「ユーザとのインタラクション」がトリガーとなって変化します。インタラクションは基本的に機能を持つMolecule ないし　Atom単位のコンポーネントで発生するため、そのインタラクションがどんな状態の変化に繋がり、その変化の影響範囲はどうなっているのか、このデータの流れを見極めることが状態管理の難しさに繋がっていると思います。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#to-flux-or-not-to-flux)To flux or not to flux

少し"コンポーネント設計"という命題からは脇道それるかもしれないんですが、避けては通れないテーマだと思うので言及しておきます。

"状態管理"に取り組む際にまず考えることが「fluxアーキテクチャを採用するかどうか」だと思います。fluxはざっくり言うとデータの流れを一方向に限定して、状態管理をしやすくするためのアーキテクチャです。fluxを使う場合コンポーネントの外でStore層を設けて状態を管理するので、採用有無はコンポーネントの設計に影響を与えます。

▼ よく見るflux の図  
[![flux-diagram.png](Clippings/assets/フロントエンドのコンポーネント設計に立ち向かう%20-%20Qiita-2025-04-26%2016-23-34/flux-diagram.png)](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F150569%2F41f7cd50-765f-7eb6-badf-8e0b5917bb2d.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=e2acdddbe11a311ef6ed0820e79628ff)

詳しい解説は本記事の趣旨から逸れるので、他の良い記事をよければご覧ください

-   [Fluxとはなんなのか](https://qiita.com/knhr__/items/5fec7571dab80e2dcd92)
-   [ReactとFluxとReduxについて順を追って整理する](https://hogehuga.com/post-1095/)

私はfluxの本質は「データの流れを見えやすくすることによってバグの少ない・デバッグのしやすい状態管理を実現すること」にあると捉えています。逆に言うとあまりコンポーネントの階層も扱う状態も多くない小中規模のアプリケーションであれば必要はないでしょう。登場人物が無駄に増えて辛みが増します。

Redux作者の Dan Abramov も有名な格言を残しています。

> Flux libraries are like glasses: you’ll know when you need them.
> 
> — Dan Abramov (@dan\_abramov) [2016年2月29日](https://twitter.com/dan_abramov/status/704304462739939328?ref_src=twsrc%5Etfw)

> fluxライブラリはメガネのようなものである。それが必要になった時に知るのだ。

個人的にはとりあえずReduxやVuexを入れちゃう風潮がよろしくないと思っていて、ReactやVueはそれ単体でもかなり強力なツールなので、本当に必要なのかはしっかり考えてから導入しましょう。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#container%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88-%E3%81%A8-presentational%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88)"Containerコンポーネント" と "Presentational"コンポーネント

Reduxに触れたことのある方なら割と当たり前の概念になりますが、基本的にコンポーネントは"Containerコンポーネント"と"Presentationalコンポーネント"に分けて考えましょう。また、「下位コンポーネントはなるべく状態を持たないようにする」という考え方は何らかのfluxライブラリなどを使っていなくとも、コンポーネント設計においては基本的な考えになると思います。

まず用語の説明ですが、"Presentationalコンポーネント"　は名前の通り見た目だけに責務を持ち、自身では状態を持ちません。

▼ "Presentationalコンポーネント"

```

const Link = ({
  active,
  children,
  onClick
}) => {
  if(active){
    return <span>{children}</span>;
  }
  return (
    <a href="#"
      onClick={e => {
        e.preventDefault();
        onClick();
      }}
    >
      {children}
    </a>
  )
}
```

基本はコンポーネントを扱う親のコンポーネントからデータなどを流し込んでもらいます。

"Containerコンポーネント"は"Presentationalコンポーネント"にデータを注ぎ込んだり、イベント発生時のコールバック関数を渡したりするのが役目です。

```
const LinkContainer = (props) => <Link {...props.link} />
```

基本的に状態は可能な限り散らばせずに管理した方が幸せなので、これらの区切りを意識して設計すると良いでしょう。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AB%E9%96%89%E3%81%98%E3%81%9F%E7%8A%B6%E6%85%8B)コンポーネントに閉じた状態

上記で"可能な限り"と言った理由としてグローバルなStore層などにわざわざ渡すと逆に煩雑になるケースがあるからです。

Reduxとか初めて使った時に、みんな疑問に感じるんじゃないかと勝手に思っているのが「テキストフィールドのinputのstateをグローバルStoreに入れるのか？」という状況です。

```
const hoge = ({
  text,
  handleChange
}) => {
  return (
    <form>
      <input type="text" onChange={e => handleChange(e.target.value)} value={text}/>
    </form>
  );
}
```

こんななんの変哲も無い `input` 要素があるとして、入力された値は`handleChange`の引数として渡され、その先には更に `action`や`reducer` が……流石にめんどくさくないですか？ちょっとツールに使われている感がします。

これに対して私は「その状態が一つのコンポーネントに閉じているかどうか」という基準で振り分けています。例えば上記の例、テキストフィールドが編集されている時の値って他のコンポーネントに影響を与えないですよね？また、一度入力した値を送信してしまえばリセットされます。これをわざわざそのコンポーネント外に展開して管理するメリットが見当たりません。

このように「状態がコンポーネントに閉じている」場合はむしろそのコンポーネントで管理した方が楽になるでしょう。状態は必ずしも一箇所に全て集めなければならない訳ではなく、状況に応じてローカルの状態管理と使い分けていきましょう。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#%E5%85%B1%E9%80%9A%E3%81%AE%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84%E3%82%92%E6%8A%BD%E5%87%BA%E3%81%99%E3%82%8B%E3%81%9D%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AE%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%82%92%E7%9F%A5%E3%82%8B)共通の振る舞いを抽出する・その実装のパターンを知る

いろんなコンポーネントで使われる共通の振る舞いは、その振る舞い自体を抽出しましょう。例えば「選択されているものだけスタイルを変える」とか「ログインしている人だけ見れる」などなどありがちな振る舞いは抽出してしまうのが良いです。

これをできるようにしておくことで一つのコンポーネントから様々なコンポーネントが柔軟に生み出せるようになります。  
例えば、先の例で言うと、ただのボタンコンポーネントから「選択されているものだけスタイルを変えるボタンコンポーネント」と「ログインしている人だけ見れるボタンコンポーネント」が簡単に生成できるようになります。もし振る舞いを抽出しない場合はそれぞれ別個のコンポーネントとして定義する必要があり、非常に煩雑です。

これを実装するパターンはいくつかあるんですが、メジャーなものとしては`Higher Order Component`や`Render Prop`があります。詳細については他の記事を紹介いたします。中身はReactベースですが、考え方は他のコンポーネントベースのライブラリでも適用できると思います。

-   [ReactのHigher Order Components詳解 : 実装の2つのパターンと、親Componentとの比較](https://postd.cc/react-higher-order-components-in-depth/)
-   [Render Props](https://reactjs.org/docs/render-props.html)

(自分の記事の宣伝になりますがVue使いの人は[こちら](https://qiita.com/seya/items/abccdd7b502535844659) を是非ご覧ください)

## [](https://qiita.com/seya/items/8814e905693f00cdade2#%E3%81%9D%E3%81%AE%E4%BB%96%E3%81%AE%E8%A9%B1)その他の話

この項では実際にコンポーネント指向で書いていく上で、あるあるな課題を挙げて行きます。正直粒度も中身も若干ゆるふわですがご了承ください。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#3%E5%BA%A6%E7%9B%AE%E3%81%AE%E6%B3%95%E5%89%87)3度目の法則

タイトルは 「リファクタリング(Martin Fowlerの本)」 からパクってきました。概念上はAtomに分解できなくはないけど、1箇所でしか使われないUIパーツ、あると思います。これはデザインシステムをどう作って行きたいかの方針にもよるんですが、原則コンポーネント化の目的は再利用性を高めることです。

なので、そもそも再利用の必要性がないものに関してはコンポーネントとして切り出さないほうが結果として無駄なファイルが減らせて良いと思います。

ここで提案したいのが `3度目の法則`。要は3回出現したら単一のコンポーネントとして切り出す、というルールを設けると意思決定がスムーズかと思います。  
好みによっては 3回でなく2回でもいいかもしれません。

### [](https://qiita.com/seya/items/8814e905693f00cdade2#prop-drilling-%E5%95%8F%E9%A1%8C)"prop drilling" 問題

コンポーネントの階層が深くなってくると表出してくる問題、それが"prop drilling問題"です。  
末端のコンポーネントに3階層4階層と上のコンポーネントのデータを受け渡したいとなった場合に、ひたすら中間のコンポーネントでも余計にデータの受け渡しのインターフェイスを作らなければならないという手間が発生します。

この問題を解決する際によくReduxなりMobXなりが使われるんですが、もしこれだけが解きたい課題なのであればあまりオススメできません。そもそもそれらのツールが解こうとしている課題は別のことであるというのと、それらのツールを使う手間と"props drilling問題"に向き合う手間はそんなに変わらないと思うからです。

ではどうすればいいかという話なんですが、最近だとReactではv16.3から新しくなった[Context API](https://reactjs.org/docs/context.html)を使えば解決できるでしょう。Vueとかだと…どうすると綺麗なんですかね…？誰か知っていたら教えてください。

## [](https://qiita.com/seya/items/8814e905693f00cdade2#%E3%81%82%E3%81%A8%E3%81%8C%E3%81%8D)あとがき

作るアプリケーションにもよりますが、コンポーネント設計は「これだ！」という正解が見えづらいと思います。なぜなら、ユーザとのインタラクションに責務を持つ部分であるがゆえに概念・論理の綺麗さだけではどうにかできない状況が存在するからです。このインタラクションの品質を上げるために、時には実装上の複雑性を受け入れることも必要でしょう。

ただ、闇雲に複雑にするのではなく、一定のルールを設けることによって負債化のリスクを減らせることはできるはずです。この記事で書いてあることを参考にしとけば大丈夫とはとても言えないですが、多少参考になれば幸いです。

それでは、Happy Coding!